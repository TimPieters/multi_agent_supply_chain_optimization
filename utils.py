import json
from pulp import LpStatus, LpStatusOptimal, LpStatusInfeasible
import time
import os
import traceback
import re

# --- extracting and modifying model code. ---

# Placeholder in the source code where constraints will be inserted
DATA_CODE_STR = "### DATA MANIPULATION CODE HERE ###"
# Placeholder in the source code where constraints will be inserted
CONSTRAINT_CODE_STR = "### CONSTRAINT CODE HERE ###"

def _read_source_code(file_path: str) -> str:
    """
    Reads the source code of a Python model file.

    Args:
        file_path (str): Path to the Python file.

    Returns:
        str: The source code as a string.
    """
    try:
        with open(file_path, "r", encoding="utf-8") as file:
            return file.read()
    except Exception as e:
        raise ValueError(f"Error reading the file '{file_path}': {e}")


def _replace(src_code: str, old_code: str, new_code: str) -> str:
    """
    Replaces an old code snippet with new code inside a source string.

    Args:
        src_code (str): The source code to modify.
        old_code (str): The code block to be replaced.
        new_code (str): The new code block to insert.

    Returns:
        str: The modified source code.
    """
    # Escape special characters in old_code to match literally
    old_code_escaped = re.escape(old_code)

    # Find the correct indentation level
    pattern = rf"(\s*){old_code_escaped}"
    match = re.search(pattern, src_code)

    if not match:
        raise ValueError(f"The specified old_code was not found in the source code.")

    head_spaces = match.group(1)  # Capture leading spaces
    indented_new_code = "\n".join([head_spaces + line for line in new_code.split("\n")])

    # Replace the old code with the correctly formatted new code
    return re.sub(pattern, indented_new_code, src_code)

def _run_with_exec(src_code: str) -> str:
    """
    Executes a dynamically modified PuLP model and extracts the results.

    Args:
        src_code (str): The source code containing the modified PuLP model.

    Returns:
        str: The optimization result (objective value) or an error message.
    """
    print("\nlog - Running optimization model...")  

    locals_dict = {}
    locals_dict.update(globals())  
    locals_dict.update(locals())   

    try:
        print("\nlog - Executing model source code...")  
        exec(src_code, locals_dict, locals_dict)

        print("\nlog - Model execution completed.")  
        
        # Retrieve results
        result = _get_optimization_result(locals_dict)

        # Display results
        print("\nlog - Optimization Completed.")
        print(f"Status: {result['status']}")
        print(f"Total Cost: {result['total_cost']}")
        print("Solution:")
        for key, value in result['solution'].items():
            print(f"  - {key}: {value}")

        return result

    except Exception as e:
        print("\nExecution Error:", traceback.format_exc())  
        return f"Execution Error:\n{traceback.format_exc()}"

def _get_optimization_result(locals_dict: dict) -> dict:
    """
    Extracts results from a solved PuLP optimization model.

    Args:
        locals_dict (dict): Dictionary containing execution context with `model` and `variables`.

    Returns:
        dict: A dictionary containing:
            - 'status': Solver status (Optimal, Infeasible, etc.).
            - 'solution': Non-zero decision variable values.
            - 'total_cost': Objective function value if solved optimally.
    """
    print("\nlog - Extracting optimization results...")  

    if "model" not in locals_dict:
        print("Error: `model` not found in execution context.")
        return {"status": "Error", "message": "model not found in execution context."}

    model = locals_dict["model"]
    status = model.solve()

    result = {
        "status": LpStatus[status],
        "raw_status": status,  # PuLPâ€™s internal status code
        "solution": {},
        "total_cost": None
    }

    # Check if the model is infeasible and return immediately
    if status == LpStatusInfeasible:
        result["message"] = "The model is infeasible. The constraints are conflicting."
        return result

    if status == LpStatusOptimal:
        result["solution"] = {
            var.name: var.value() for var in model.variables()
            if var.value() is not None and var.value() >= 0
        }
        result["total_cost"] = model.objective.value()

    print("\nlog - Optimization results extracted.")  
    return result


def format_constraint_input(constraint_code: str) -> str:
    """
    Ensures the constraint is formatted correctly before inserting it into the model.
    
    Args:
        constraint_code (str): The constraint generated by the agent.
    
    Returns:
        str: A properly formatted constraint statement.
    """
    print("CONSTRAINT CODE " + constraint_code)
    # Ensure there are no unnecessary backticks or formatting issues
    constraint_code = constraint_code.strip().strip("`")
    print("STRIPPED CONSTRAINT CODE " + constraint_code)
    # Remove backticks (`, ```) and strip enclosing quotes if the whole string is quoted
    if constraint_code.startswith(("'", '"', "`")) and constraint_code.endswith(("'", '"', "`")):
        constraint_code = constraint_code[1:-1].strip()

        # Remove unmatched trailing or leading quote
    if constraint_code.endswith('"') and not constraint_code.startswith('"'):
        constraint_code = constraint_code[:-1].strip()
    if constraint_code.startswith('"') and not constraint_code.endswith('"'):
        constraint_code = constraint_code[1:].strip()

    # Ensure the constraint is a valid Python statement
    if not constraint_code.startswith("model +="):
        constraint_code = f"model += {constraint_code}"
    
    return constraint_code

def _clean_agent_code(raw_code: str, code_type: str) -> str:
    """
    Cleans syntax issues from LLM-generated code, adds prefix for constraints.

    Args:
        raw_code (str): Agent output string.
        code_type (str): One of 'ADD DATA' or 'ADD CONSTRAINT'.

    Returns:
        str: Clean and executable Python code.
    """
    code = raw_code.strip().strip("`")

    if code.startswith(("'", '"')) and code.endswith(("'", '"')):
        code = code[1:-1].strip()

    if code.endswith('"') and not code.startswith('"'):
        code = code[:-1].strip()
    if code.startswith('"') and not code.endswith('"'):
        code = code[1:].strip()

    if code_type == "ADD CONSTRAINT" and not code.startswith("model +="):
        code = f"model += {code}"

    return code


def _apply_model_modification(source_code: str, operations: dict) -> str:
    """
    Modifies the model's source code by inserting agent-generated data or constraint blocks.

    Args:
        source_code (str): Original code as string.
        operations (dict): Dictionary with keys like 'ADD DATA' or 'ADD CONSTRAINT'
                           and string or list-of-strings as values.

    Returns:
        str: Modified source code with inserted code blocks.
    """
    updated_code = source_code

    if not isinstance(operations, dict):
        raise ValueError("Operations must be a dictionary with keys like 'ADD DATA' or 'ADD CONSTRAINT'.")

    for op_type, code_blocks in operations.items():
        if not isinstance(code_blocks, list):
            code_blocks = [code_blocks]

        for block in code_blocks:
            cleaned_block = _clean_agent_code(block, op_type)

            if op_type == "ADD DATA":
                updated_code = _replace(updated_code, DATA_CODE_STR, cleaned_block)
            elif op_type == "ADD CONSTRAINT":
                updated_code = _replace(updated_code, CONSTRAINT_CODE_STR, cleaned_block)
            else:
                raise ValueError(f"Unsupported operation: {op_type}")

    return updated_code

def modify_and_run_model(modification_json: dict) -> str:
    """
    Applies a structured modification (e.g., adding data or constraints), executes the supply chain model, and returns results.

    Args:
        modification_json (dict or str): A JSON specifying the operation(s).

    Returns:
        str: The optimization results or error message.
    """
    try:
        if isinstance(modification_json, str):
            modification_json = modification_json.strip().strip("`")
            try:
                modification_json = json.loads(modification_json)
            except json.JSONDecodeError as json_err:
                return f"JSON decoding error: {json_err.msg}. Please ensure keys and strings use double quotes. Make sure you don't include ```json ... ``` in the tool input."

        if not isinstance(modification_json, dict):
            raise ValueError("Parsed input is not a dictionary. Ensure proper JSON format with double quotes.")

        model_code = _read_source_code("multi_agent_supply_chain_optimization/capfacloc_model.py")
        modified_code = _apply_model_modification(model_code, modification_json)
        result = _run_with_exec(modified_code)

        return result

    except Exception as e:
        return f"Error during modification or execution: {str(e)}"