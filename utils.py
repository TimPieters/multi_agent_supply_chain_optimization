import json
from pulp import LpStatus, LpStatusOptimal, LpStatusInfeasible, LpProblem, LpVariable
import time
import os
import traceback
import re
import io
import pulp
import networkx as nx
import pandas as pd
import matplotlib.pyplot as plt

# --- extracting and modifying model code. ---

# Placeholder in the source code where constraints will be inserted
DATA_CODE_STR = "### DATA MANIPULATION CODE HERE ###"
# Placeholder in the source code where constraints will be inserted
CONSTRAINT_CODE_STR = "### CONSTRAINT CODE HERE ###"

def _read_source_code(file_path: str) -> str:
    """
    Reads the source code of a Python model file.

    Args:
        file_path (str): Path to the Python file.

    Returns:
        str: The source code as a string.
    """
    try:
        with open(file_path, "r", encoding="utf-8") as file:
            return file.read()
    except Exception as e:
        raise ValueError(f"Error reading the file '{file_path}': {e}")


def _replace(src_code: str, old_code: str, new_code: str) -> str:
    """
    Replaces an old code snippet with new code inside a source string.

    Args:
        src_code (str): The source code to modify.
        old_code (str): The code block to be replaced.
        new_code (str): The new code block to insert.

    Returns:
        str: The modified source code.
    """
    # Escape special characters in old_code to match literally
    old_code_escaped = re.escape(old_code)

    # Find the correct indentation level
    pattern = rf"(\s*){old_code_escaped}"
    match = re.search(pattern, src_code)

    if not match:
        raise ValueError(f"The specified old_code was not found in the source code.")

    head_spaces = match.group(1)  # Capture leading spaces
    indented_new_code = "\n".join([head_spaces + line for line in new_code.split("\n")])

    # Replace the old code with the correctly formatted new code
    return re.sub(pattern, indented_new_code, src_code)

def _run_with_exec(src_code: str) -> str:
    """
    Executes a dynamically modified PuLP model and extracts the results.

    Args:
        src_code (str): The source code containing the modified PuLP model.

    Returns:
        str: The optimization result (objective value) or an error message.
    """
    print("\nlog - Running optimization model...")  

    locals_dict = {}
    locals_dict.update(globals())  
    locals_dict.update(locals())   

    try:
        print("\nlog - Executing model source code...")  
        exec(src_code, locals_dict, locals_dict)

        print("\nlog - Model execution completed.")  
        
        # Retrieve results
        result = _get_optimization_result(locals_dict)

        # Display results
        print("\nlog - Optimization Completed.")
        print(f"Status: {result['status']}")
        print(f"Total Cost: {result['total_cost']}")
        print("Solution:")
        for key, value in result['solution'].items():
            print(f"  - {key}: {value}")

        return result

    except Exception as e:
        print("\nExecution Error:", traceback.format_exc())  
        return f"Execution Error:\n{traceback.format_exc()}"

def _get_optimization_result(locals_dict: dict) -> dict:
    """
    Extracts results from a solved PuLP optimization model.

    Args:
        locals_dict (dict): Dictionary containing execution context with `model` and `variables`.

    Returns:
        dict: A dictionary containing:
            - 'status': Solver status (Optimal, Infeasible, etc.).
            - 'solution': Non-zero decision variable values.
            - 'total_cost': Objective function value if solved optimally.
    """
    print("\nlog - Extracting optimization results...")  

    if "model" not in locals_dict:
        print("Error: `model` not found in execution context.")
        return {"status": "Error", "message": "model not found in execution context."}

    model = locals_dict["model"]
    status = model.solve()

    result = {
        "status": LpStatus[status],
        "raw_status": status,  # PuLPâ€™s internal status code
        "solution": {},
        "total_cost": None
    }

    # Check if the model is infeasible and return immediately
    if status == LpStatusInfeasible:
        result["message"] = "The model is infeasible. The constraints are conflicting."
        return result

    if status == LpStatusOptimal:
        result["solution"] = {
            var.name: var.value() for var in model.variables()
            if var.value() is not None and var.value() >= 0
        }
        result["total_cost"] = model.objective.value()

    print("\nlog - Optimization results extracted.")  
    return result


def format_constraint_input(constraint_code: str) -> str:
    """
    Ensures the constraint is formatted correctly before inserting it into the model.
    
    Args:
        constraint_code (str): The constraint generated by the agent.
    
    Returns:
        str: A properly formatted constraint statement.
    """
    print("CONSTRAINT CODE " + constraint_code)
    # Ensure there are no unnecessary backticks or formatting issues
    constraint_code = constraint_code.strip().strip("`")
    print("STRIPPED CONSTRAINT CODE " + constraint_code)
    # Remove backticks (`, ```) and strip enclosing quotes if the whole string is quoted
    if constraint_code.startswith(("'", '"', "`")) and constraint_code.endswith(("'", '"', "`")):
        constraint_code = constraint_code[1:-1].strip()

        # Remove unmatched trailing or leading quote
    if constraint_code.endswith('"') and not constraint_code.startswith('"'):
        constraint_code = constraint_code[:-1].strip()
    if constraint_code.startswith('"') and not constraint_code.endswith('"'):
        constraint_code = constraint_code[1:].strip()

    # Ensure the constraint is a valid Python statement
    if not constraint_code.startswith("model +="):
        constraint_code = f"model += {constraint_code}"
    
    return constraint_code

def _clean_agent_code(raw_code: str, code_type: str) -> str:
    """
    Cleans syntax issues from LLM-generated code, adds prefix for constraints.

    Args:
        raw_code (str): Agent output string.
        code_type (str): One of 'ADD DATA' or 'ADD CONSTRAINT'.

    Returns:
        str: Clean and executable Python code.
    """
    code = raw_code.strip().strip("`")

    if code.startswith(("'", '"')) and code.endswith(("'", '"')):
        code = code[1:-1].strip()

    if code.endswith('"') and not code.startswith('"'):
        code = code[:-1].strip()
    if code.startswith('"') and not code.endswith('"'):
        code = code[1:].strip()

    if code_type == "ADD CONSTRAINT" and not code.startswith("model +="):
        code = f"model += {code}"

    return code


def _apply_model_modification(source_code: str, operations: dict) -> str:
    """
    Modifies the model's source code by inserting agent-generated data or constraint blocks.

    Args:
        source_code (str): Original code as string.
        operations (dict): Dictionary with keys like 'ADD DATA' or 'ADD CONSTRAINT'
                           and string or list-of-strings as values.

    Returns:
        str: Modified source code with inserted code blocks.
    """
    updated_code = source_code

    if not isinstance(operations, dict):
        raise ValueError("Operations must be a dictionary with keys like 'ADD DATA' or 'ADD CONSTRAINT'.")

    for op_type, code_blocks in operations.items():
        if not isinstance(code_blocks, list):
            code_blocks = [code_blocks]

        for block in code_blocks:
            cleaned_block = _clean_agent_code(block, op_type)

            if op_type == "ADD DATA":
                updated_code = _replace(updated_code, DATA_CODE_STR, cleaned_block)
            elif op_type == "ADD CONSTRAINT":
                updated_code = _replace(updated_code, CONSTRAINT_CODE_STR, cleaned_block)
            else:
                raise ValueError(f"Unsupported operation: {op_type}")

    return updated_code

def modify_and_run_model(modification_json: dict) -> str:
    """
    Applies a structured modification (e.g., adding data or constraints), executes the supply chain model, and returns results.

    Args:
        modification_json (dict or str): A JSON specifying the operation(s).

    Returns:
        str: The optimization results or error message.
    """
    try:
        if isinstance(modification_json, str):
            modification_json = modification_json.strip().strip("`")
            try:
                modification_json = json.loads(modification_json)
            except json.JSONDecodeError as json_err:
                return f"JSON decoding error: {json_err.msg}. Please ensure keys and strings use double quotes. Make sure you don't include ```json ... ``` in the tool input."

        if not isinstance(modification_json, dict):
            raise ValueError("Parsed input is not a dictionary. Ensure proper JSON format with double quotes.")

        model_code = _read_source_code("multi_agent_supply_chain_optimization/capfacloc_model.py")
        modified_code = _apply_model_modification(model_code, modification_json)
        result = _run_with_exec(modified_code)

        return result

    except Exception as e:
        return f"Error during modification or execution: {str(e)}"
    

# ======== PuLP Model Util Functions =========

def get_objective_function(model):
    """
    Returns the objective function of the PuLP model.
    
    Args:
        model: A PuLP LpProblem instance
        
    Returns:
        The objective function object
    """
    return model.objective

def get_constraints(model):
    """
    Returns all constraints in the PuLP model.
    
    Args:
        model: A PuLP LpProblem instance
        
    Returns:
        A dictionary of constraints where keys are constraint names
    """
    return model.constraints

def get_variables(model):
    """
    Returns all variables in the PuLP model.
    
    Args:
        model: A PuLP LpProblem instance
        
    Returns:
        A list of all variables in the model
    """
    return model.variables()

def get_mps_format(model):
    """
    Exports the model to MPS format and returns the filename.
    
    Args:
        model: A PuLP LpProblem instance
        
    Returns:
        The filename of the exported MPS file
    """
    # Export the model to MPS format
    filename = f"{model.name}.mps"
    model.writeMPS(filename)
    
    print(f"Model exported to MPS format: {filename}")
    return filename

def get_lp_format(model):
    """
    Exports the model to LP format and returns the filename.
    
    Args:
        model: A PuLP LpProblem instance
        
    Returns:
        The filename of the exported LP file
    """
    # Export the model to LP format
    filename = f"{model.name}.lp"
    model.writeLP(filename)
    
    print(f"Model exported to LP format: {filename}")
    return filename

def build_model_from_lp(lp_file):
    """
    Builds a PuLP model from an LP file.
    
    Args:
        lp_file: Path to the LP file
        
    Returns:
        A new PuLP LpProblem instance
    """
    # Create a new empty model
    model = pulp.LpProblem(name=lp_file.replace('.lp', ''))
    
    print(f"Model built from LP file: {lp_file}")
    return model

def build_model_from_mps(mps_file):
    """
    Builds a PuLP model from an MPS file.
    
    Args:
        mps_file: Path to the MPS file
        
    Returns:
        A new PuLP LpProblem instance
    """
    variables_dict, model = pulp.LpProblem.fromMPS(mps_file, sense=pulp.LpMinimize)
    
    print(f"Model built from MPS file: {mps_file}")
    return model


def pulp_model_to_networkx(model):
    """
    Convert a PuLP model to a NetworkX bipartite graph for analysis and visualization.

    Args:
        model: A PuLP LpProblem instance

    Returns:
        G: A NetworkX graph representing the model structure
    """
    # Create an empty graph
    G = nx.Graph()

    # Get variables and constraints
    variables = model.variables()
    constraints = model.constraints

    # Add variable nodes
    for var in variables:
        var_type = "binary" if var.cat == pulp.LpBinary else "continuous"
        G.add_node(var.name, bipartite=0, type='variable', var_type=var_type)

    # Add constraint nodes
    for constraint_name, constraint in constraints.items():
        G.add_node(constraint_name, bipartite=1, type='constraint')

    # Add objective node
    objective_name = "Objective"
    G.add_node(objective_name, bipartite=1, type='objective')

    # Build edges between variables and constraints
    for constraint_name, constraint in constraints.items():
        # constraint.expr is an LpAffineExpression
        for var, coef in constraint.expr.items():
            # Add edge only if coefficient is nonzero
            if abs(coef) > 1e-15:
                G.add_edge(var.name, constraint_name, weight=coef)

    # Build edges for the objective function
    # model.objective is also an LpAffineExpression
    for var, coef in model.objective.items():
        if abs(coef) > 1e-15:
            G.add_edge(var.name, objective_name, weight=coef)

    return G

def plot_pulp_model_graph(G):
    """
    Plot the bipartite PuLP model graph using NetworkX and matplotlib.

    Args:
        G: A NetworkX graph returned by pulp_model_to_networkx.
    """
    # Separate nodes by 'bipartite' set or by 'type' attribute
    variable_nodes = [n for n, d in G.nodes(data=True) if d.get('bipartite') == 0]
    other_nodes = [n for n, d in G.nodes(data=True) if d.get('bipartite') == 1]

    # Use a bipartite layout, placing all 'bipartite=0' nodes on one side
    pos = nx.bipartite_layout(G, variable_nodes)

    # Create the plot
    plt.figure()
    nx.draw(G, pos, with_labels=True)

    # Draw coefficient labels on edges
    edge_labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

    # Show the figure
    plt.show()


def get_model_stats(G):
    """
    Calculate statistics from a model graph.
    
    Args:
        G: NetworkX graph of the model
        
    Returns:
        stats: Dictionary of model statistics
    """
    variable_nodes = [n for n, d in G.nodes(data=True) if d.get('type') == 'variable']
    binary_vars = [n for n, d in G.nodes(data=True) 
                  if d.get('type') == 'variable' and d.get('var_type') == 'binary']
    continuous_vars = [n for n, d in G.nodes(data=True) 
                      if d.get('type') == 'variable' and d.get('var_type') == 'continuous']
    
    constraint_nodes = [n for n, d in G.nodes(data=True) if d.get('type') == 'constraint']
    
    stats = {
        "num_variables": len(variable_nodes),
        "num_binary_vars": len(binary_vars),
        "num_continuous_vars": len(continuous_vars),
        "num_constraints": len(constraint_nodes),
        "num_connections": G.number_of_edges(),
        "graph_density": nx.density(G),
        "average_constraint_degree": sum(G.degree(c) for c in constraint_nodes) / len(constraint_nodes) if constraint_nodes else 0,
        "average_variable_degree": sum(G.degree(v) for v in variable_nodes) / len(variable_nodes) if variable_nodes else 0
    }
    
    return stats


if __name__ == "__main__":
    # Read the source code from file
    print("Reading source code from 'multi_agent_supply_chain_optimization/capfacloc_model.py'...")
    src_code = _read_source_code("multi_agent_supply_chain_optimization/capfacloc_model.py")
    print(f"Source code read successfully. Length: {len(src_code)} characters")
    
    # Create locals and globals dictionaries
    print("Setting up execution environment...")
    locals_dict = {}
    locals_dict.update(globals())  
    locals_dict.update(locals())   
    print("Execution environment set up successfully")
    
    # Execute the source code
    print("Executing model source code...")
    exec(src_code, locals_dict, locals_dict)
    print("Model source code executed successfully")
    
    # Get the model from the locals dictionary
    print("Retrieving model from execution context...")
    model = locals_dict["model"]
    print(f"Model retrieved successfully: {model.name}")
    
    # Example usage with print statements:
    print("\n---------- OBJECTIVE FUNCTION ----------")
    objective = get_objective_function(model)
    print(f"Objective function: {objective}")
    print(f"Objective function type: {type(objective)}")
    print(f"Objective function name: {objective.name}")
    
    print("\n---------- CONSTRAINTS ----------")
    constraints = get_constraints(model)
    print(f"Number of constraints: {len(constraints)}")
    print(f"Constraint names: {list(constraints.keys())[:5]}... (showing first 5)")
    
    print("\n---------- VARIABLES ----------")
    variables = get_variables(model)
    print(f"Number of variables: {len(variables)}")
    print(f"First 5 variables: {[v.name for v in variables[:5]]}... (showing first 5)")
    
    print("\n---------- MPS FORMAT ----------")
    print("Exporting model to MPS format...")
    mps_file = get_mps_format(model)
    print(f"Model exported to MPS file: {mps_file}")
    
    print("\n---------- LP FORMAT ----------")
    print("Exporting model to LP format...")
    lp_file = get_lp_format(model)
    print(f"Model exported to LP file: {lp_file}")
    
    print("\n---------- BUILDING MODEL FROM LP ----------")
    print("Building new model from LP file...")
    new_model_from_lp = build_model_from_lp(lp_file)
    print(f"Model name: {new_model_from_lp.name}")
    print(f"Number of constraints: {len(new_model_from_lp.constraints)}")
    print(new_model_from_lp)
    
    print("\n---------- BUILDING MODEL FROM MPS ----------")
    print("Building new model from MPS file...")
    new_model_from_mps = build_model_from_mps(mps_file)
    print(f"Model name: {new_model_from_mps.name}")
    print(f"Number of constraints: {len(new_model_from_mps.constraints)}")
    # print(new_model_from_mps)
    # print("Solving model... \n")
    # new_model_from_mps.solve()

    print("\nGenerate graph: \n\n")
    G = pulp_model_to_networkx(new_model_from_mps)
    plot_pulp_model_graph(G)

    graph_stats = get_model_stats(G)
    print(graph_stats)
